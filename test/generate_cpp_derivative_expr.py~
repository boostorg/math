from sympy import quo
from sympy import symbols, simplify, ccode
from sympy.tensor.array import derive_by_array
import sys

def generate_cpp_tensor(expr, vars, order):
    derivatives = expr
    for _ in range(order):
        derivatives = derive_by_array(derivatives, vars)

    def flatten(tensor):
        if not hasattr(tensor, '__iter__') or isinstance(tensor, (str, bytes)):
            return [tensor]
        if hasattr(tensor, 'tolist'):
            tensor = tensor.tolist()
        flat_list = []
        for e in tensor:
            flat_list.extend(flatten(e))
        return flat_list

    flat_derivs = flatten(derivatives)

    def index_to_suffix(idx):
        return ''.join([str(vars[i]) for i in idx])

    def generate_indices(d, order):
        if order == 0:
            return [[]]
        else:
            smaller = generate_indices(d, order - 1)
            return [s + [i] for s in smaller for i in range(d)]

    all_indices = generate_indices(len(vars), order)

    var_names = []
    for idx in all_indices:
        suffix = ''.join(str(vars[i]) for i in idx)
        var_names.append(f"f_{suffix}")
    code_lines = []
    for var_name, expr in zip(var_names, flat_derivs):
        simplified = simplify(expr)
        c_expr = ccode(simplified)
        code_lines.append(f"    T {var_name} = static_cast<T>({c_expr});")
    return_line = "    return { " + ', '.join(var_names) + " };"
    return '\n'.join(code_lines) + '\n' + return_line

if __name__ == "__main__":
    x, y, z = symbols('x y z')
    vars = [x, y]
    f = x/(y+x)*y/(x-y)
    order = int(sys.argv[1]) if len(sys.argv) > 1 else 2

    print(f"// Order-{order} derivative of f(x, y, z) = {f}")
    print("template<typename T>")
    print("std::vector<T> gf_a(T x, T y) {")
    print(generate_cpp_tensor(f, vars, order))
    print("}")
