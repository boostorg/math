[/
Copyright (c) 2017 Nick Thompson
Use, modification and distribution are subject to the
Boost Software License, Version 1.0. (See accompanying file
LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:diff Numerical Differentiation]

[heading Synopsis]

``
  #include <boost/math/tools/numerical_differentiation.hpp>
``

  namespace boost { namespace math { namespace tools {

   template <class F, class Real>
   Real complex_step_derivative(const F f, Real x);

   template <class F, class Real, size_t order = 6>
   Real finite_difference_derivative(const F f, Real x, Real* error);

  }}} // namespaces

[heading Description]

The function __finite_difference_derivative calculates a finite-difference approximation to the derivative of of a function /f/ at point /x/.
A basic usage is

    __auto f = [](double x) { return std::exp(x); };
    __double x = 1.7;
    __double d = finite_difference_derivative(f, x);

It is well-known that finite-difference approximations to the derivative are ill-conditioned.
However, by careful choice of the stepsize the calculation can be made marginally robust in practice.
Given the great effort involved in computing stable derivatives for the veritable zoo of special functions used in applied mathematics,
it seems reasonable to instead have a general purpose routine.

Unlike many other numerical differentiation algorithms, boost's __finite_difference_derivative does not require the user to input a stepsize.
Boost chooses the stepsize that minimizes the maximum theoretical error, under the assumption that the evaluation of the function can achieve an accuracy of 1ULP.
For more details about the theoretical error analysis involved in finite-difference approximations to the derivative, see [@http://web.archive.org/web/20150420195907/http://www.uio.no/studier/emner/matnat/math/MAT-INF1100/h08/kompendiet/diffint.pdf here].
In the real world, however, functions are rarely evaluated to 1ULP, so the error estimate is returned under the assumption that the function is evaluated within +/-3ULP.

The error can be queried as follows

    __double error_estimate;
    __double d = finite_difference_derivative(f, x, &error_estimate);

N.B.: Producing an error estimate requires additional function evaluations and as such is slower than simple evaluation of the derivative.
It also expands the domain over which the function must be differentiable.

The default order of accuracy is 6, which reflects that fact that people tend to be interested in functions with many continuous derivatives.
If your function does not have 7 continuous derivatives, is may be of interest to use a lower order method, which can be achieved via (say)

    __double d = finite_difference_derivative<decltype(f), Real, 2>(f, x);

This requests a second-order accurate derivative be computed.

It is emphatically /not/ the case that higher order methods give higher accuracy for smooth functions.
Higher order methods require more additions of positive and negative terms, which can lead to catastrophic cancellation.
A function which is very good at making a mockery of finite-difference differentiation is exp(x)/(cos(x)[sup 3] + sin(x)[sup 3]).
Differentiating this function in double precision at /x=5.5/ gives zero correct digits at order 4, 6, and 8, but recovers 5 correct digits at order 2.
These are dangerous waters; use the error estimates to tread carefully.

For a finite-difference method of order /k/, the error is /C/\u03B5[sup k/k+1].
In the limit /k/ to \u221E, we see that the error tends to \u03B5, recovering the full precision for the type unless |f'(x)| /u226A /u03B5.
However, this ignores the fact that higher-order methods require subtracting more nearly-equal terms, so the constant /C/ grows with /k/.
Since /C/ grows quickly and \u03B5[sup k/k+1] approaches \u03B5 slowly, we can see that a compromise between high-order accuracy and conditioning of the difference quotient.
In practice we have found that /k=6/ seems to be a good compromise, but users are encouraged to examine the error estimates to choose an optimal order of accuracy for the given problem.
In general, finite difference approximations to the derivative are highly inaccurate around as |f'(x)| tends to zero, reflecting the ill-conditioned nature of function evaluation in this regime.
Another inaccurate regime occurs when \u03B5[sup k/k+1]|f(x)| is not small; this occurs for functions with exponential growth evaluated at large arguments.

[table:id Cost of Finite-Difference Numerical Differentiation
    [[Order of Accuracy] [Function Evaluations] [Error]            [Differentiability required for error estimate to hold] [Additional Function Evaluations to Produce Error Estimates]]
    [[1]                 [2]                    [\u03B5[sup 1/2]]  [2]                                                     [1]]
    [[2]                 [2]                    [\u03B5[sup 2/3]]  [3]                                                     [2]]
    [[4]                 [4]                    [\u03B5[sup 4/5]]  [5]                                                     [2]]
    [[6]                 [6]                    [\u03B5[sup 6/7]]  [7]                                                     [2]]
    [[8]                 [8]                    [\u03B5[sup 8/9]]  [9]                                                     [2]]
]


Given all the caveats which must be kept in mind for successful use of finite-difference differentiation, it is reasonable to try to avoid it if possible.
Boost provides one such possibility: If your function is the restriction to the real line of a holomorphic function which takes real values at real argument, then the miraculous *complex step derivative* can be used.
The idea is very simple: Since /f/ is complex-differentiable, /f(x+ih) = f(x) + ihf'(x) - h[sup 2]f''(x) + [bigo](h[sup 3])/.
As long as /f(x) \u2208 \u211D/, then /f'(x) = \u2111[f(x+ih)]/h + [bigo](h[sup 2])/.
This method requires a single complex function evaluation and is not subject to the catastrophic subtractive cancellation that plagues finite-difference calculations.

An example usage:

    __double x = 7.2;
    __double e_prime = complex_step_derivative(std::exp<std::complex<double>>, x);


[endsect]
