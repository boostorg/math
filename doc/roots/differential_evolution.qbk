[/
Copyright (c) 2023 Nick Thompson
Use, modification and distribution are subject to the
Boost Software License, Version 1.0. (See accompanying file
LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:differential_evolution Differential Evolution]

[heading Synopsis]

``
    #include <boost/math/tools/differential_evolution.hpp>
    
    namespace boost::math::tools {

    template <typename BoundsContainer>
    class differential_evolution {
    public:
        using BoundType = BoundsContainer::value_type;
        using Real = BoundType::value_type;

        differential_evolution(BoundsContainer bounds, Real F = 0.65, double crossover_ratio = 0.5, 
                               size_t NP = 200, size_t max_generations = 1000, 
                               size_t threads = std::thread::hardware_concurrency());

        template <typename ArgumentContainer, class Func, class URBG>
        ArgumentContainer argmin(const Func cost_function, URBG &g,
                                  ArgumentContainer* initial_guess = nullptr,
                                  std::invoke_result_t<Func, ArgumentContainer> target_value = 
                                      std::numeric_limits<std::invoke_result_t<Func, ArgumentContainer>>::quiet_NaN(),
                                  std::atomic<bool> *cancellation = nullptr,
                                  std::vector<std::pair<ArgumentContainer, std::invoke_result_t<Func, ArgumentContainer>>>
                                      *queries = nullptr,
                                  std::atomic<std::invoke_result_t<Func, ArgumentContainer>>* current_minimum_cost = nullptr);
    };

    } // namespaces
``

The `differential_evolution` class provides an implementation of the (classical) differential evolution optimization algorithm, often going by the label `de/rand/bin/1`.
It is capable of minimizing a cost function defined on a continuous space represented by a set of bounds.

[heading Constructor]

``
differential_evolution(BoundsContainer bounds, Real F = 0.8, double crossover_ratio = 0.5, 
                       size_t NP = 1000, size_t max_generations = 1000, size_t threads = std::thread::hardware_concurrency());
``

Parameters:

    `bounds`: A container representing the bounds of the optimization space. The `.size()` of the bounds should return the dimension of the problem, and each element of the `bounds` should have two elements of the same type.
    `F`: The scale factor controlling the rate at which the population evolves (default is 0.65).
    `crossover_ratio`: The crossover ratio determining the trade-off between exploration and exploitation (default is 0.5).
    `NP`: The population size (default is 200). Parallelization occurs over the population, so this should be "large".
    `max_generations`: The maximum number of generations for the optimization (default is 1000).
    `threads`: The number of threads to use for parallelization (default is the hardware concurrency). If the objective function is already multithreaded, then this should be set to 1 to prevent oversubscription.

The defaults were chosen by a reading of Price, Storn, and Lampinen, chapter 3, with the exception of the population size, which we have chosen a bit larger than they found as core counts have increased since publication of this reference and parallelization occurs within each generation.
There is a tradeoff between finding global minima and convergence speed.
The most robust way of decreasing the probability of getting stuck in a local minima is to increase the population size.

[heading Member Function]

``
template <typename ArgumentContainer, class Func, class URBG>
ArgumentContainer argmin(const Func cost_function, URBG &rng,
                         ArgumentContainer* initial_guess = nullptr,
                         std::invoke_result_t<Func, ArgumentContainer> target_value = 
                              std::numeric_limits<std::invoke_result_t<Func, ArgumentContainer>>::quiet_NaN(),
                         std::atomic<bool> *cancellation = nullptr,
                         std::vector<std::pair<ArgumentContainer, std::invoke_result_t<Func, ArgumentContainer>>>
                              *queries = nullptr,
                         std::atomic<std::invoke_result_t<Func, ArgumentContainer>>* current_minimum_cost = nullptr);
``

Parameters:

    `cost_function`: The cost function to be minimized.
    `rng`: A uniform random bit generator, like `std::mt19937_64`.
    `initial_guess`: An optional initial guess for the optimal solution.
    `value_to_reach`: An optional value that, if reached, stops the optimization. This is the most robust way to terminate the calculation, but in most cases the optimal value of the cost function is unknown, but if it is, use it! See the referenced book for clear examples of when target values can be deduced. 
    `cancellation`: An optional atomic boolean to allow the user to stop the computation and gracefully return the best result found up to that point. N.B.: Cancellation is not immediate; the in-progress generation finishes.
    `queries`: An optional vector to store intermediate results during optimization. This is useful for debugging and perhaps volume rendering of the objective function after the calculation is complete.
    `current_minimum_cost`: An optional atomic variable to store the current minimum cost during optimization. This allows developers to (e.g.) plot the progress of the minimization over time and in conjunction with the `cancellation` argument allow halting the computation when the progress stagnates. Refer to Price, Storn, and Lampinen, Section 3.2 for caveats with this approach.

Returns:

The argument vector corresponding to the minimum cost found by the optimization.

[h4:examples Examples]

Examples can be found in [@../../test/differential_evolution_test.cpp differential_evolution_test.cpp].

[h5:caveats Caveats]

We have decided to only support classic `de/rand/1/bin` because there are too many parameters for this class as it stands, and we have not seen benchmarks that indicate that other variants of the algorithm perform better.
If a compelling usecase is provided, support for the `de/x/y/z` variants can be added.

Supported termination criteria are explicit requests for termination, value-to-reach, and max generations.
Price, Storn, and Lampinen, Section 2.8 also list population statistics and lack of accepted trials over many generations as sensible termination criteria.
These could be supported if there is demand.

[h4:references References]

* Price, Kenneth, Rainer M. Storn, and Jouni A. Lampinen. ['Differential evolution: a practical approach to global optimization.] Springer Science & Business Media, 2006.

[endsect] [/section:differential_evolution Differential Evolution]
