[/
Copyright (c) 2017 Nick Thompson
Use, modification and distribution are subject to the
Boost Software License, Version 1.0. (See accompanying file
LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:double_exponential Double-exponential quadrature]

[section:tanh_sinh_over Overview]

The tanh-sinh quadrature routine provided by boost is a rapidly convergent numerical integration scheme for holomorphic integrands.
By this we mean that the integrand is the restriction to the real line of a complex-differentiable function which is bounded on the interior of the unit disk /|z| < 1/.
More precisely, the integrands must lie within a Hardy space.
If your integrand obeys these conditions, it can be shown that tanh-sinh integration is optimal, meaning that it requires the fewest function evaluations for a given accuracy of any quadrature algorithm for a random element from the Hardy space.
A basic example of how to use the tanh-sinh quadrature is shown below:

    __double tolerance = sqrt(std::numeric_limits<double>::epsilon());
    __size_t max_interval_halvings = 8;
    __tanh_sinh<double> integrator(tolerance, max_interval_halvings);
    __auto f = [](double x) { return 5*x + 7; };
    __double error;
    __double L1_norm
    __double Q = integrator.integrate(f, (double) 0, (double) 1, &error, &L1_norm);

Although you have requested a certain tolerance, the routine is not bound to honor it.
For this reason, you should pass in a pointer to a variable holding the error, which will be populated with the final error estimate.
The only time that the error estimate will exceed the tolerance is when the maximum number of interval halvings was attained.
Since the estimates are generally still quite good, it seems more reasonable to simply state the final error and return an estimate than throw an exception.

One very nice property of tanh-sinh quadrature is that it can handle singularities at the endpoints of the integration domain.
For instance, the following integrand, singular at both endpoints, can be efficiently evaluated to 100 binary digits:

    __auto f = [](Real x) { return log(x)*log(1-x); };
    __Real Q = integrator.integrate(f, (Real) 0, (Real) 1);

Although boost's implementation of tanh-sinh quadrature can achieve very high precision, it is not truly arbitrary precision.
The reason is that vast speed improvements can be obtained by caching the weights and abscissas of the variable transformation

    __tanh(pi<Real>()*sinh(t)/2);

These numbers have been precomputed up to 100 binary digits, so this is roughly the most precision that can be expected from the quadrature.
We think that this is a reasonable compromise between efficiency, accuracy, and compile time that will satisfy the vast majority of users.


Now onto the caveats: As stated before, the integrands must lie in a Hardy space to ensure rapid convergence.
Attempting to integrate a function which is not bounded on the unit disk by tanh-sinh can lead to very slow convergence.
For example, take the Runge function:

    __auto f1 = [](double t) { return 1/(1+25*t*t); };
    __Q = integrator.integrate(f1, (double) -1, (double) 1);

This function has poles at \pm i/5, and as such it is not bounded on the unit disk.
However, the related function

    __auto f2 = [](double t) { return 1/(1+0.04*t*t); };
    __Q = integrator.integrate(f2, (double) -1, (double) 1);

has poles outside the unit disk (at \pm 5i), and is therefore in the Hardy space.
The integration is performed 22x faster for the second function!
If you do not understand the structure of your integrand in the complex plane, do performance testing before deployment.

Like the trapezoidal quadrature, the tanh-sinh quadrature produces an estimate of the L[sub 1] norm of the integral along with the requested integral.
This is to establish a scale for the integral, as well as to provide an estimate of the condition number of the summation.
This can be queries as follows:


    __double tolerance = sqrt(std::numeric_limits<double>::epsilon());
    __size_t max_halvings = 15;
    __tanh_sinh<double> integrator(tolerance, max_halvings);
    __auto f = [](double x) { return 5*x + 7; };
    __double error;
    __double L1;
    __double Q = integrator.integrate(f, (double) 0, (double) 1, &error, &L1);
    __double condition_number = L1/std::abs(Q);

If the condition number is large, the computed integral is worthless.
Occasionally, the condition number will be so large that a `boost::math::evaluation_error` will be thrown.
However, the class is very conservative; throwing only when the condition number is so large that the integral is essentially guaranteed to be worthless (when it exceeds the reciprocal of the unit roundoff).

Often, the computation is very poor well before the condition number exceeds this threshold,
so it is the responsibility of the user to check the L[sub 1] norm computation and evaluate whether it is acceptable.

Although the tanh-sinh quadrature can compute integral over infinite domains by variable transformations, these transformations can create a very poorly behaved integrand.
For this reason, double-exponential variable transformations have been provided that allow stable computation over infinite domains; these being the exp-sinh and sinh-sinh quadrature.

The sinh-sinh quadrature allows computation over the entire real line, and is called as follows:

    __sinh_sinh<double> integrator;
    __auto f = [](double x) { return exp(-x*x); };
    __double error;
    __double L1;
    __double Q = integrator.integrate(f, &error, &L1);

Note that the limits of integration are understood to be (-infinity, infinity).

For half-infinite intervals, the exp-sinh quadrature is provided:

    __exp_sinh<double> integrator;
    __auto f = [](double x) { return exp(-3*x); };
    __double error;
    __double L1;
    __double Q = integrator.integrate(f, (Real) 0, std::numeric_limits<Real>::infinity(), &error, &L1);

Either the left limit or the right limit must be infinite; and not both.
Both the sinh-sinh and exp-sinh quadratures are truly arbitrary precision, and require the abscissas and weights to be computed at runtime.
This means that the call to the constructor is expensive, so make sure to reuse the object for multiple integrations (if, say you are assembling a stiffness matrix).


[endsect]
