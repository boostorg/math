[/
Copyright (c) 2021 Nick Thompson
Use, modification and distribution are subject to the
Boost Software License, Version 1.0. (See accompanying file
LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:bilinear_uniform Bilinear Uniform Interpolation]

[heading Synopsis]

``
#include <boost/math/interpolators/bilinear_uniform.hpp>

namespace boost::math::interpolators {

template <class RandomAccessContainer>
class bilinear_uniform
{
public:
    using Real = typename RandomAccessContainer::value_type;

    bilinear_uniform(RandomAccessContainer && fieldData, decltype(fieldData.size()) rows, decltype(fieldData.size()) cols, Real dx = 1, Real dy = 1, Real x0 = 0, Real y0 = 0)

    Real operator()(Real x, Real y) const;

    std::array<Real,2> gradient(Real x, Real y) const;
};
``


[heading Bilinear Uniform Interpolation]

The bilinear uniform interpolator takes a grid of data points specified by a linear index and interpolates between each segment using a bilinear function.
Note that "bilinear" does not mean linear-a product of two linear functions can be 
 /f/(/x/, /y/)
The interpolant is /C/[super 2] and its evaluation has [bigo](log(/N/)) complexity.
An example usage is as follows:

    std::vector<double> v{0.1, 0.2,
                          0.3, 0.4};
    using boost::math::interpolators::bilinear_uniform;
    int rows = 2;
    int cols = 2;
    double dx = 1;
    double dy = 1;
    double x0 = 0;
    double y0 = 0;
    auto bu = bilinear_uniform(std::move(v), rows, cols, dx, dy, x0, y0);
    // evaluate at a point:
    double z = bu(0.0, 0.0);

Periodically, it is helpful to see what data the interpolator has.
This can be achieved via

    std::cout << ub << "\n";

Note that the interpolator is pimpl'd, so that copying the class is cheap, and hence it can be shared between threads.
(The call operator and `.gradient()` are threadsafe.)


[heading Complexity and Performance]

The following google benchmark demonstrates the cost of the call operator for this interpolator:

```
Run on (16 X 4300 MHz CPU s)
CPU Caches:
  L1 Data 32K (x8)
  L1 Instruction 32K (x8)
  L2 Unified 1024K (x8)
  L3 Unified 11264K (x1)
Load Average: 0.92, 0.64, 0.35
--------------------------------------------------
Benchmark                                  Time
--------------------------------------------------
```


[endsect]
[/section:bilinear_uniform]
