[section:polynomials Estrin's method for polynomial evaluation]

[h4 Synopsis]

``
#include <boost/math/tools/estrin.hpp>
``

   namespace boost::math::tools {
 
   // Advanced interface: Use if you can preallocate a scratch buffer of size (coeffs.size() +1)/2:
   // This is *unchecked*, so use at your own risk!
   template<typename RandomAccessContainer1, typename RandomAccessContainer2, typename RealOrComplex>
   inline auto estrin(RandomAccessContainer1 const & coeffs, RandomAccessContainer2& scratch, RealOrComplex z);

   // Template specialization for std::array, no preallocation is necessary so some performance improvements may be observed:
   template <typename RealOrComplex1, size_t n, typename RealOrComplex2>
   inline RealOrComplex2 estrin(const std::array<RealOrComplex1, n> &coeffs, RealOrComplex2 z);

   // Easy interface: Preallocates the correctly sized scratch buffer:
   template <typename RandomAccessContainer, typename RealOrComplex>
   inline RealOrComplex estrin(const RandomAccessContainer &coeffs, RealOrComplex z);
   } //    namespaces 

[h4 Description]

Boost.math provided free functions which evaluate polynomials by Estrin's method.
Though Estrin's method is not optimal from the standpoint of minimizing arithmetic operations (that claim goes to Horner's method),
it nonetheless is well-suited to SIMD pipelines on modern CPUs.
For example, on an 2022 M1 Pro, evaluating a double precision polynomial of length N using Estrin's method with scratch space takes 0.28 N nanoseconds for large N.
For comparison, using Horner's method takes 1.24 N ns.
However, for small N, Horner's method is faster; to wit, we have observed that for N roughly greater than 90, Estrin's method is better.
These numbers are highly dependent on compiler flags; ensure the compiler is allowed to emit AVX instructions and fmas to take full advantage of the benefits of Estrin's method.

To see performance on your system, refer to the google benchmark file `reporting/performance/estrin_performance.cpp`.


[h4 References]

* Muller, Jean-Michel (2005). Elementary Functions: Algorithms and Implementation (2nd ed.). Birkh√§user. p. 58. ISBN 0-8176-4372-9.

[/
  Copyright 2023 Thomas Dybdahl Alhe, Nicholas Thompson, Matt Borland

  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]
